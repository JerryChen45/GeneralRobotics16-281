from motorgo import ControlMode
from motorgo.plink import Plink
import time

LEFT_CH = 3
RIGHT_CH = 1

def clamp(v, lo, hi):
    return max(min(v, hi), lo)

def sgn(x: float) -> float:
    return 1.0 if x > 0 else (-1.0 if x < 0 else 0.0)

def main():
    plink = Plink()
    plink.connect()
    imu = plink.imu

    left = getattr(plink, f"channel{LEFT_CH}")
    right = getattr(plink, f"channel{RIGHT_CH}")

    left.control_mode = ControlMode.POWER
    right.control_mode = ControlMode.POWER

    # -------------------------
    # Inner loop (balance PD + feedforward)
    # -------------------------
    k_p = 30.0
    k_d = 0.23
    k_ff = 0.10      # Feedforward on theta_set (start 0.05–0.15)
    u_max = 0.9

    # Optional: friction/deadband compensation (set to 0.0 to disable)
    u_dead = 0.00    # e.g. 0.03–0.08 if motors have strong stiction

    prev_error = 0.0
    prev_t = time.time()

    # -------------------------
    # Outer loop (position hold) PD -> theta_set
    # -------------------------
    outer_k_p = 0.3
    outer_k_d = 0.2
    theta_max = 0.08

    outer_hz = 60.0
    outer_dt_target = 1.0 / outer_hz
    outer_accum = 0.0
    outer_prev_t = time.time()

    def read_wheel_pos():
        # NOTE: .position units depend on your hardware (ticks/rad/etc.)
        l = float(left.position)
        r = float(right.position)
        return l, r

    # Reference position (start point)
    l0, r0 = read_wheel_pos()
    x_ref = 0.5 * (l0 + r0)

    prev_x = x_ref
    theta_set = 0.0

    while True:
        # -------------------------
        # Inner-loop timing (~200 Hz)
        # -------------------------
        t = time.time()
        dt = t - prev_t
        if dt <= 0:
            continue
        prev_t = t

        # -------------------------
        # Outer loop update (~60 Hz)
        # -------------------------
        outer_accum += dt
        while outer_accum >= outer_dt_target:
            outer_accum -= outer_dt_target

            lpos, rpos = read_wheel_pos()
            x = 0.5 * (lpos + rpos)

            now = time.time()
            outer_dt = now - outer_prev_t
            if outer_dt <= 0:
                outer_dt = outer_dt_target
            outer_prev_t = now

            xdot = (x - prev_x) / outer_dt
            prev_x = x

            e_x = x_ref - x
            theta_cmd = outer_k_p * e_x - outer_k_d * xdot
            theta_set = clamp(theta_cmd, -theta_max, theta_max)

        # -------------------------
        # Inner loop: balance around theta_set
        # -------------------------
        theta = float(imu.gravity_vector[1])

        error = theta_set - theta
        d_error = (error - prev_error) / dt
        prev_error = error

        # PD + feedforward
        u = k_p * error + k_d * d_error + k_ff * theta_set

        # Optional stiction compensation
        if u_dead > 0.0:
            u += u_dead * sgn(u)

        u = clamp(u, -u_max, u_max)
        print(u)

        # Motor directions: may need sign flips depending on your wiring/convention
        left.power_command = -u
        right.power_command =  u

        # Keep prints light; too-fast printing can disturb timing
        # print(f"theta={theta:.4f} theta_set={theta_set:.4f} u={u:.3f}")

        time.sleep(0.005)

if __name__ == "__main__":
    main()
